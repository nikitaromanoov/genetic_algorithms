# Лабораторная работа №3 Генетический алгоритм для задачи оптимизации непрерывной функции
## Цель работы
Целью данной лабораторной работы является получение студентом навыков разработки и анализа эволюционных операторов генетического алгоритма для решения задачи оптимизации непрерывной вещественнозначной функции.
## Оборудование и программное обеспечение
Для выполнения лабораторной работы потребуется:
* браузер с доступом к сети Интернет
* Java JDK версии 1.8 и выше
* Watchmaker framework  версии 0.7.1
## Ход работы
Откроем проект, полученный по адресу: https://gitlab.com/itmo_ec_labs/lab2, который состоит из классов, описанных далее.
### MyAlg.java 
В данном классе дана основная структура генетического алгоритма с его параметрами и необходимыми функциями, данная часть кода в дальнейшем не будет меняться в ходе работы. Параметры, которые будут меняться в ходе работы:

* Параметр  dimension - определяет размерность проблемы, т.е. количество переменных в векторе решения.
* Параметр populationSize - устанавливает количество индивидов в популяции
* Параметр generations - количество итераций алгоритма, т.е. поколений, которое будет сгенерировано в процессе эволюции решений.

### FitnessFunction.java

Это целевая функция, она уже определена и реализована и в рамках лабораторной работы и изменять ее не нужно.

### MyFactory.java

В этом классе необходимо самостоятельно реализовать инициализацию индивида. В рамках лабораторной работы есть ограничение:

* область определения всех переменных целевой функции: [−5, 5];
* область значений функции: [0, 10].
* глобальный оптимум: 10.

Будем их соблюдать в этом и дальнейших классах. 

Инициализацию будем реализовывать следующим образом: случайно генерируем массив чисел из промежутка от -5 до 5 длиной равной параметру dimension, заданному в классе MyAlg.java.

### MyCrossover.java;

В этом классе реализован кроссовер. Наследуемая от класса фреймворка функция принимает на вход два родительских решения и требует на выходе
список с новыми решениями. Мной был реализован арифметический кроссовер, суть которого в том, что часть генов дочернего решения наследуется от одного предка, а значения оставшихся генов рассчитываются как промежуточные значения между генами двух предков.


$$ z_{i} = {a* x_{i} + (1-a)* y_{i}} $$

В работе реализовано, что параметр a может принимать любое значение, но во всех экспериментах использовалось значение 0.5.
Решение о том, данный ген брать от родители или же искать по формуле принимается случайно с вероятностью 0.5.



### MyMutation.java

В данном классе реализована мутация. На вход функции подаётся список со всеми индивидами в популяции. Можно выделить два типа мутации: равномерная и неравномерная.

Неравномерная мутация подразумевает сдвиг решения по одной или нескольким осями. Она позволяет проводить локальный поиск за счет небольших изменений в окрестностях текущей локации индивида. Сдвиг решения будет от -0.5 до 0.5.  Мутацию будем реализовывать не для всех представителей популяции, а лишь до определенного количества -  количество особей с равномерной мутацией. Также мутацию будем производить не для каждого гена, а только для части из них - количество генов со сдвигом.

Помимо равномерной мутациии реализуем еще и неравномерную. В таком случае изменении значения гена в рамках нижней и верхней границы теряется его прошлое состояние, но зато такой тип мутации позволяет выйти за границы локального оптимума. Такой тип мутации также будем применять не для всех особей, а для лишь маленького количества, чтобы не потерять важную информацию -  количество особей с неравномерной мутацией. При этом в таком случае будем изменять большее количество генов -  количество генов с полным изменением.  



### Эксперимент


Проведем серию запусков при размерностях проблемы: 2, 10, 20, 50 и 100 для анализа производительности реализованного генетического алгоритма. В процессе эксперимента настроим параметры размера популяции (левая часть таблицы) и другие дополнительные параметры алгоритма и операторов (правая часть таблицы).


Результаты экспермента представлены в таблицы ниже:

![image](https://user-images.githubusercontent.com/91135334/221501307-f7723d62-dbd6-4381-bc00-39b1d82667cf.png)



Размер популяции на всех экспериментах оставался один и тот же, поскольку это давало лучшее качество результатов. Количество итераций всегда оставалось примерно одинаковым, поскольку при таком размере популяции количество фитнес-оценок было превышено ранее, чем кончилось заданное количество поколений. При более маленьких размерностях проблемы хороший результат можно было получить еще раньше, так при размерности - 2, результат похожий на наилучший был получен еще на 1000 итераций. 

### Ответы на вопросы

1. Что важнее, кроссовер или мутация?

Важны оба оператора, поскольку в комбинации они позволяет добиться наилучших результатов.

2. Как влияет значение параметра "размер популяции" на производительность и эффективность алгоритма?

Чем больше размер популяции, тем ниже производительность, но выше эффективность.  Посмотрим на дополнительный эксперимент, показанный ниже:


![image](https://user-images.githubusercontent.com/91135334/221499504-18286562-01ae-4311-a678-086a507317df.png)

Заметим, что чем больше размер популяции, тем лучше результат, но это занимает и больше времени, поскольку нужно высчитывать большее количество фитнесс-функцией.

3. Важно ли знать область определения переменных целевой функции?

Да, важно, поскольку при инициализации, мутации или кроссовере можно случайно выйти за рамки области определения и получить ошибку при вычислении целевой функции.  





