# Лабораторная работа №1: "Сложность алгоритмов и их оптимизации"
## Цель работы
Получить навыки вычисления сложности алгоритмов и их оптимизации различными методами.
## Ход работы
### 1. Реализовать на любом ЯП алгоритм, согласно варианту задания.
Вариант задания 18 - "Сортировка выбором". Язык программирования - Python.
```python3
def sort(data, reverse=False):
  length = len(data)
  for n in range(length):
    maximum = n
    for i in range(n+1, length):
      if data[i] > data[maximum]:
        maximum = i
    z = data[maximum]
    data[maximum] = data[n]
    data[n] =  z
  if reverse:
    return data[::-1]
  return data
```
### 2. Вычислить сложность алгоритма, привести расчёты, результаты нагрузочных тестов с замером затраченного времени и ресурсов.

$$ Количество_-операций =  (n-1) + (n-2) + ... + 1 = n^2 /2$$

Тогда сложность алгоритма $O(n^2)$

Для нагрузочных тестов было сгенерировано 100 списков, которые далее были отсортировано по 10 раз каждый для того, чтобы получить средние результаты. Занимаемая оперативная память - минимальная и не показывается на ресерах, процессор занят на 100%:

До теста:

![image](https://user-images.githubusercontent.com/91135334/218318278-ccd718c2-5a3c-4df5-b1aa-baddfaadae5e.png)

Во время теста:

![image](https://user-images.githubusercontent.com/91135334/218318255-85505064-98de-45e8-a2d1-5ac600112990.png)

Время выполнения: 3.871

![image](https://user-images.githubusercontent.com/91135334/218318496-78eb4bae-fd70-4ee7-8f64-978967e07db1.png)

### 3. Выполнить оптимизацию как алгоритмическую если возможно, с выносом инварианта, например, так и программными методами выбранного ЯП.
Поскольку невозможно выполнить алгоритмическую оптимизацию, так как это будет уже другой алгоритм, поскольку суть алгоритма в обмене минимального значения в текущем списке со значением первой неотсортированной позициии.
Но можно выполнить оптимизацию с использованием програмнных методов языка  Python. Так как поиск минимального/максимального элемента - это общий алгоритм, мы не можем найти max/min в общем случае, не проверив их все. В Python также нет встроенного типа отсортированной коллекции, который упростил бы специализацию проверки, но можно использовать функцию min/max, которая реализована на  CPython, тем самым избегая накладных расходов интерпретатора байт-кода, которые понес бы дополнительный цикл for.
В итоге код будет следующий:
```python3
def sort2(data, reverse=False):
  for n in range(len(data)):
    maximum = max(data[n:])
    z = data[data.index(maximum)]
    data[data.index(maximum)] = data[n]
    data[n] =  z
  return data
```

### 4. Вычислить сложность оптимизированного алгоритма, привести расчёты, результаты нагрузочных тестов с замером затраченного времени и ресурсов.
Среднее время сортировки 1 списка: 2.235

![image](https://user-images.githubusercontent.com/91135334/218318552-731922c9-59fd-4c80-ad38-bc566b114b2a.png)


По ресурсам ситуация не отличается от неоптимизированной версии сортировки выбором:

![image](https://user-images.githubusercontent.com/91135334/218318414-a013e124-5a19-4859-b499-d871393ce1f2.png)


### 5. Описать различие величин сложности, результатов, привести обоснование.
Сложность осталась такой же, поскольку для изменения сложности было бы неозодимо полностью поменить соритровку и это бы уже не была сортировка выбором. Результаты по времени улучшились на 73% (3.871 -> 2.235)
### 6. Сформулировать выводы.
Таким образом, можно оптимизировать код за счет того, чтобы использовать реализацию опредленных часте кода на других языках, что часто используется на практике.
### 7. Приложить код в виде ссылки на публичный репозиторий.
Ссылка на репозиторий: https://github.com/nikitaromanoov/genetic_algorithms/tree/main/lab1
