# Лабораторная работа №5 Проектирование эволюционного алгоритма для задачи расстановки ферзей

## Цель работы
Целью данной работы является освоение принципов построения распределенных и параллельных эволюционных алгоритмов для повышения их производительности и эффективности.
## Оборудование и программное обеспечение
Для выполнения лабораторной работы потребуется:
* браузер с доступом к сети Интернет;
* Java JDK версии 1.8 и выше;
* Watchmaker framework версии 0.7.1.
## Ход работы

Для работы используются разработки из лабораторной работы №3 : https://github.com/nikitaromanoov/genetic_algorithms/tree/main/lab3, а именно инициализация, кроссовер и мутация.

Предположим, что размерность проблемы dimension = 50, а размер популяции 100.

Для анализа производительности двух моделей
параллельных алгоритмов необходимо получить последовательный алгоритм.
Для этих целей, в классе MasterSlaveAlg.java необходимо вызвать функцию
algorithm.setSingleThreaded(true) после создания схемы алгоритма
(AbstractEvolutionEngine<double[]> algorithm). При передаче в функцию
значения true, алгоритм будет работать в однопотоковом режиме.


Для построения островной модели необходимо
создать объект IslandEvolution<double[]> island_model в классе IslandsAlg.java.
Для этого необходимо вызвать конструктор класса с необходимым набором
параметров. В качестве стратегии миграции можно выбрать реализованную в
рамках фрэймворка стратегию RingMigration.

Также был реализован функционал для замера времени работы алгоритмов и были сравнены три три алгоритма: однопоточный, master-slave и островной. Все эксперименты проводились с одинаковым размером популяции и количестве итераций. 

Каждая серия экспериментов проводится для определенного значения
параметра complexity, который представляет собой
множитель сложности вычисления фитнес-функции. Сложность заключается в
повторном вычислении одной и той же функции.

В каждой серии экспериментов было проведено
по 10 запусков каждого алгоритма для получения усредненных значений.
Как результат работы предоставляется таблица с замерами:
![image](https://user-images.githubusercontent.com/91135334/228211781-edcb761b-5cb9-4c97-81a6-5ad8b0f68311.png)


А также графики зависимостей времени выполнения и результата работы каждого алгоритма от значения параметра complexity.

#### График зависимости времени от уровня сложности
![image](https://user-images.githubusercontent.com/91135334/228214332-e4eb7785-76e7-415e-b097-32c2fe3d57ca.png)

Заметим, что очень сильно растет время выполнения у алгоритма  single thread.

#### График зависимости качества решения от уровня сложности
![image](https://user-images.githubusercontent.com/91135334/228214372-4bff77f7-d935-425a-abfd-588806c95cf7.png)

Очевидно, что от сложности качество решения не меняется, поскольку сложность овтечает лишь за количество раз, когда вычислялась функция.



### Ответы на вопросы



1. Какая модель алгоритма лучше при каких условиях?

Распределенный и островной алгоритм позволяют оптимизировать вычисление фитнесс функции. В то время как более хороший результат был у распределенного и однопоточного алгоритма. Каждый алгоритм лучше для определенных задач. 

2. Как повлияет увеличение размерности проблемы на алгоритмы?

Увеличение размерности проблемы имеет слабое влияние на скорость распределенного алгоритма и более высокою на островную модель.

Это сильно повлияет на время работы островного алгоритма, в  то время как время работы распределенного и однопоточного алгоритма увеличится не сильно.

3. Как повлияет увеличение размера популяции?

Увеличение размера популяции улучшит результаты (эффективность), при этом увеличится время.

4. Есть ли ограничение для количества островов?

Мы ограничены ресурсами вычислительного устройства. Также в рамках данной лабораторной работы, где у нас фиксированный размер популяции мы ограничены еще и тем фактом, что у нас уменьшается размер популяции для каждого острова приу велечении их количества, а слишком маленькое значение может привести нас к очень плохим результатам. 







