# Лабораторная работа №5 Проектирование эволюционного алгоритма для задачи расстановки ферзей

## Цель работы
Целью данной работы является освоение принципов построения распределенных и параллельных эволюционных алгоритмов для повышения их производительности и эффективности.
## Оборудование и программное обеспечение
Для выполнения лабораторной работы потребуется:
* браузер с доступом к сети Интернет;
* Java JDK версии 1.8 и выше;
* Watchmaker framework версии 0.7.1.
## Ход работы

Для работы используются разработки из лабораторной работы №3 : https://github.com/nikitaromanoov/genetic_algorithms/tree/main/lab3, а именно инициализация, кроссовер и мутация.

Предположим, что размерность проблемы dimension = 50, а размер популяции 100.

Для анализа производительности двух моделей
параллельных алгоритмов необходимо получить последовательный алгоритм.
Для этих целей, в классе MasterSlaveAlg.java необходимо вызвать функцию
algorithm.setSingleThreaded(true) после создания схемы алгоритма
(AbstractEvolutionEngine<double[]> algorithm). При передаче в функцию
значения true, алгоритм будет работать в однопотоковом режиме.


Для построения островной модели необходимо
создать объект IslandEvolution<double[]> island_model в классе IslandsAlg.java.
Для этого необходимо вызвать конструктор класса с необходимым набором
параметров. В качестве стратегии миграции можно выбрать реализованную в
рамках фрэймворка стратегию RingMigration.

Также был реализован функционал для замера времени работы алгоритмов и были сравнены три три алгоритма: однопоточный, master-slave и островной. Все экспременты проводились с одинаковым размером популяции и количестве итераций. 

Каждая серия экспериментов проводится для определенного значения
параметра complexity, который представляет собой
множитель сложности вычисления фитнес-функции. Сложность заключается в
повторном вычислении одной и той же функции.

В каждой серии экспериментов было проведено
по 10 запусков каждого алгоритма для получения усредненных значений.
Как результат работы предоставляется таблица с замерами:
![image](https://user-images.githubusercontent.com/91135334/228211781-edcb761b-5cb9-4c97-81a6-5ad8b0f68311.png)


А также графики зависимостей времени выполнения и результата работы каждого алгоритма от значения параметра complexity.

#### Реализация


### Эксперимент









### Ответы на вопросы


1. Какая модель алгоритма лучше при каких условиях?

2. Как повлияет увеличение размерности проблемы на алгоритмы?

3. Как повлияет увеличение размера популяции?

4. Есть ли ограничение для количества островов?







