# Лабораторная работа №6 Распределенные эволюционные алгоритмы

## Цель работы
Целью данной работы является освоение принципов построения распределенных и параллельных эволюционных алгоритмов для повышения их производительности и эффективности.
## Оборудование и программное обеспечение
Для выполнения лабораторной работы потребуется:
* браузер с доступом к сети Интернет;
* Java JDK версии 1.8 и выше;
* Watchmaker framework версии 0.7.1.
## Ход работы

Для работы используются разработки из лабораторной работы №3 : https://github.com/nikitaromanoov/genetic_algorithms/tree/main/lab3, а именно инициализация, кроссовер и мутация.

#### MyFactory.java
Инициализация реализована следующим образом: случайно генерируем массив чисел из промежутка от -5 до 5 длиной равной параметру dimension, заданному в классе MyAlg.java.

#### MyCrossover.java
В этом классе реализован кроссовер. Наследуемая от класса фреймворка функция принимает на вход два родительских решения и требует на выходе список с новыми решениями. Мной был реализован арифметический кроссовер, суть которого в том, что часть генов дочернего решения наследуется от одного предка, а значения оставшихся генов рассчитываются как промежуточные значения между генами двух предков.

$$ z_{i} = {a* x_{i} + (1-a)* y_{i}} $$

В работе реализовано, что параметр a может принимать любое значение, но во всех экспериментах использовалось значение 0.5.
Решение о том, данный ген брать от родители или же искать по формуле принимается случайно с вероятностью 0.5.

#### MyMutation.java

В данном классе реализована мутация. На вход функции подаётся список со всеми индивидами в популяции. Можно выделить два типа мутации: равномерная и неравномерная.

Неравномерная мутация подразумевает сдвиг решения по одной или нескольким осями. Она позволяет проводить локальный поиск за счет небольших изменений в окрестностях текущей локации индивида. Сдвиг решения будет от -0.5 до 0.5.  Мутацию будем реализовывать не для всех представителей популяции, а лишь до определенного количества -  количество особей с равномерной мутацией. Также мутацию будем производить не для каждого гена, а только для части из них - количество генов со сдвигом.

Помимо равномерной мутациии реализуем еще и неравномерную. В таком случае изменении значения гена в рамках нижней и верхней границы теряется его прошлое состояние, но зато такой тип мутации позволяет выйти за границы локального оптимума. Такой тип мутации также будем применять не для всех особей, а для лишь маленького количества, чтобы не потерять важную информацию -  количество особей с неравномерной мутацией. При этом в таком случае будем изменять большее количество генов -  количество генов с полным изменением. 

#### Эксперемент

Согласно условия работы размерность проблемы dimension = 50, а размер популяции 100.

Для анализа производительности двух моделей
параллельных алгоритмов необходимо получить последовательный алгоритм.
Для этих целей, в классе MasterSlaveAlg.java необходимо вызвать функцию
algorithm.setSingleThreaded(true) после создания схемы алгоритма
(AbstractEvolutionEngine<double[]> algorithm). При передаче в функцию
значения true, алгоритм будет работать в однопотоковом режиме.


Для построения островной модели необходимо
создать объект IslandEvolution<double[]> island_model в классе IslandsAlg.java.
Для этого необходимо вызвать конструктор класса с необходимым набором
параметров. В качестве стратегии миграции можно выбрать реализованную в
рамках фрэймворка стратегию RingMigration.

Также был реализован функционал для замера времени работы алгоритмов и были сравнены три три алгоритма: однопоточный, master-slave и островной. Все эксперименты проводились с одинаковым размером популяции и количестве итераций. 

Каждая серия экспериментов проводится для определенного значения
параметра complexity, который представляет собой
множитель сложности вычисления фитнес-функции. Сложность заключается в
повторном вычислении одной и той же функции.

В каждой серии экспериментов было проведено
по 10 запусков каждого алгоритма для получения усредненных значений.
Как результат работы предоставляется таблица с замерами:
![image](https://user-images.githubusercontent.com/91135334/228211781-edcb761b-5cb9-4c97-81a6-5ad8b0f68311.png)


А также графики зависимостей времени выполнения и результата работы каждого алгоритма от значения параметра complexity.

#### График зависимости времени от уровня сложности
![image](https://user-images.githubusercontent.com/91135334/228214332-e4eb7785-76e7-415e-b097-32c2fe3d57ca.png)

Заметим, что очень сильно растет время выполнения у алгоритма  single thread.

#### График зависимости качества решения от уровня сложности
![image](https://user-images.githubusercontent.com/91135334/228214372-4bff77f7-d935-425a-abfd-588806c95cf7.png)

Очевидно, что от сложности качество решения не меняется, поскольку сложность овтечает лишь за количество раз, когда вычислялась функция.



### Ответы на вопросы



1. Какая модель алгоритма лучше при каких условиях?

Распределенный и островной алгоритм позволяют оптимизировать вычисление фитнесс функции. В то время как более хороший результат был у распределенного и однопоточного алгоритма. Каждый алгоритм лучше для определенных задач. 

2. Как повлияет увеличение размерности проблемы на алгоритмы?

Это сильно повлияет на время работы островного алгоритма, в  то время как время работы распределенного и однопоточного алгоритма увеличится не сильно.

3. Как повлияет увеличение размера популяции?

Увеличение размера популяции улучшит результаты (эффективность), при этом увеличится время.

4. Есть ли ограничение для количества островов?

Мы ограничены ресурсами вычислительного устройства. Также в рамках данной лабораторной работы, где у нас фиксированный размер популяции мы ограничены еще и тем фактом, что у нас уменьшается размер популяции для каждого острова при увелечении их количества, а слишком маленькое значение может привести нас к очень плохим результатам. 







