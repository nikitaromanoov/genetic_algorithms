# Лабораторная работа №5 Проектирование эволюционного алгоритма для задачи расстановки ферзей

## Цель работы
Целью данной работы является освоение всего цикла разработки эволюционных алгоритмов, начиная с анализа проблемы и проектирования, заканчивая настройкой параметров и анализом эффективности.
## Оборудование и программное обеспечение
Для выполнения лабораторной работы потребуется:
* браузер с доступом к сети Интернет
* Python > 3.9.16
## Ход работы
1. В работе предлгаается выбрать фреймворк либо сделать свою собственную реализацию.  Я выбрал второй вариант с использованием языка программирования Python.
2. Следуюший шаг -  нужно выбрать эволюционный алгоритм, в моем случае им будет генетический алгоритм.
3. Проанилизируем задачу и опишем подзод к ее решению:

* Решения задачи будем представлять в виде списка - [x1, x2, x3 ... , xn] , где  n- размер задачи. В таком случае индекс - это строка, в которой стоит фигура, а значение - номер столбца.
* Все особи популяции будем генерировать, основываясь на том, что нет конфликта по строка и столцбам ( ферзи не стоят на одной строке или столбце, потому что в этом случае, очевидно, что они будут конлфиктовать друг с другом)
* С помощью фитнес-функции будем определять, какое количество конфликтов имеется и стремится уменьшить их количество.
* Будем заканчивать эксперемент, как только был найден подходящий вариант с оценкой фитнес-функции равной 0.


Для реализации генетического алгоритма была реализованы следующие функции:
#### def factory(N)
Эта функция предназначена для инициализации начальной популяции, она принимает на вход размер проблемы  N и генерирует список, в котором индекс - это строка, а значение - столбец.

#### def crossover(p1, p2)
Следующая необходимая функция - это кроссовер. Он реализован в данной задаче следующим образом: потомок получает от роидетелй те гены, которые совпадают у родителя 1 и  родителя 2, остальные промежутки заполняются случайными лсьавшимися генами, но так, чтобы не было повтора (поскольку значения в списке - это столбцы, а два ферзя не может находится в одном столбце)

#### def fintess_function(comb):
Фитнес функции считает количество конфликтов, а именно ситуаций, когда два ферзя могут убить друг друга. Так как при поставленном подходе задачи не может быть конфликтов по горизонтале или вертикале, то будем считать только количества по диагонале. Для этого можно воспользоваться формулой, что x2-x2=|y2-y1|, если это равенство верно, то два ферзя могут друг дурга убить - отсюда конфликт.

#### def selection(population, populations_size)
Данная функция отвечает за выбор наилучших представительей популяции для следущего поколоения. 

#### def mutation(individs, COUNT)
Эта функция реализует оператор мутации, который меняет значения двух случайных позиций в списке. COUNT - количество мутаций.


#### def selectOne(population)
Это реализация Roulette-wheel selection, которая используется для выбора особей для воспроизведения потомства. В основе идеи метода лежит представление популяции в виде колеса рулетки, где для каждой особи имеется сектор, размер которого пропорционален значению её показателя приспособленности. Но так как мы стремимся к минимизации значений, поскольку они представляют количество конфликтов, и мы хотим получить их как можно меньше, а именно ноль, чтобы решить задачу. Поэтому поделим 1 на все соответсвующие значения для того, чтобы выбирались чаще те значения, которые имеют меньшее значение оценки фитнесс-функции.


#### Реализация

Далее в ячейки кода были собраны все ранее описанные функции для полноценной реализации генетического алгоритма. Рассмотрим более детально и построчно как все работает.

В блоке ниже определяются основные параметры.

```python3
GENERATIONS = 100000
POPULATIONS_SIZE = 300
SIZE = 256
PRECENT_CROSSOVER = 0.9
best_ever = 10000000
ELETISM = 30
COUNT_MUTATION = 30
```

В следующем блоке кода мы начинаем итерацию по поколениям GENERATIONS раз. Если это 1 поколение, то мы используем функцию  factory для создания нулевого поколения. Для этого подаем ей на вход размер проблемы - SIZE.
```python3
population = []
for i in range(GENERATIONS):
  #factor
  if population == []:
    for j in range(POPULATIONS_SIZE):
      population += [factory(SIZE)]
```
Далее мы реализуем элитизм. Элитизм подразумевает, что одна или несколько особей текущего поколения переходят в следующее, не подвергаясь каким-либо изменениям, в отличие от всех остальных особей. Обычно в качестве элитной особи выбирается особь с наилучшим значением целевой функции, что и было реализовано.

```python3
 # elitism
 new_population = []
 df = pd.DataFrame({"individ":population, "score": [fintess_function(i) for i in population]})
 df = df.sort_values("score")
 base = list(df["individ"][:ELETISM])
```

В следующем блоке создается новое количество особей, равное  PRECENT_CROSSOVER*(POPULATIONS_SIZE/2).
```python3
# crossover
for j in range(round(PRECENT_CROSSOVER*round(POPULATIONS_SIZE/2))):
  new_population += [crossover(selectOne(df[~df.astype(str).duplicated()].reset_index()),selectOne(df))]
population += new_population
```
Далее применяется мутация, задаваемая параметром COUNT_MUTATION.

```python3
#mutation
random.shuffle(population)
population = mutation(population, COUNT_MUTATION)
```
После этого проводится селекция, учитывающая тот факт, что был применен элитизм.
```python3
#selection
population, best_score = selection(population, POPULATIONS_SIZE- ELETISM)
population = base + population
```
В конце выводится номер поколения, лучшая особь в этом поколении, не считая элитарных, и лучшая особь существовавшая когда-либо. Если решение было найдено ( количество ошибок равно 0), то  выполнение генетического алгоритма прекращается
```python3
if best_score < best_ever:
  best_ever = best_score

print(f"Generation #{i}, best_score_ever = {best_ever}, best_current_score = {best_score}")
  if best_score == 0:
    break
```
### Эксперимент

Был проведен экспремент в виде серии запусков при разных значениях  N.  Для того, чтобы резуьтаты были действительными, было проведено по 10 запусков на каждую размерность и записаны среднии значения. Это связано с тем, что генетичский алгоритм всегда работает по разному в связи с наличием рандома в иниициализации, мутации, кроссовере. 



Можно заметить, что чем больше разменость задачи, тем она тяжелей для решения и требуется большее количество итераций.


### Ответы на вопросы

1. Является ли задача оптимизационной или ограниченной?

В постанвоке задаче есть ряд ограничений, описаных более детально в ходе работы.

2. Как растёт сложность задачи при увеличении размерности?

Чем больше размерность задачи, тем она сложнее ( нужно больше итераций, больше размер популяции для того, чтобы достичь результата)





