# Лабораторная работа №4 Генетический алгоритм для решения задачи коммивояжёра
## Цель работы
Целью данной работы является получение навыков разработки эволюционных алгоритмов для решения комбинаторных задач на примере задачи коммивояжёра.
## Оборудование и программное обеспечение
Для выполнения лабораторной работы потребуется:
* браузер с доступом к сети Интернет
* Python > 3.9.16
## Ход работы
Задание данной лабортаорной работы по согласованию с преподавателем было реализовано на языке Python. Для этого были реализованы следующие функции:

### def factory(count_cities)
Данная функция принимает на вход количество городов и на основе эиого формирует первоначальные маршруты (первое поколение)

### def crossover(p1, p2)
Данная функция называется упорядоченным кроссовером и принимает на вход два индивида -  роидетель №1 и родитель №2. 
От родителя №1 ей достается отрезок генов от точки  a до точки b , а от родителя №2  все еще незадействованные гены, 
начиная от позиции b в порядкевторого родителя. Подробный процесс представлен на рисунке ниже


![image](https://user-images.githubusercontent.com/91135334/224931099-6895d279-bfd1-4f62-9e30-5fd6aabc6694.png)

### def fintess_function(path, dict_cities)

Данная функция оценивет присособлеванность особей популяции и выдает число, отражающее длину маршрута. Задача генетического алгоритма заключается в поиске особи с наименьшей оценкой, выданной фитнесс функцией.

### def selection(population, populations_size):
Данный оператор производит селекцию, это нужно для того чтобы размер популяции у нас оставался все время фиксированным.

### def mutation(individs)

Данная функция представляет собой оператор мутации, которй вносит изменения в особи.

В работе реализовано 4 вида мутации: 

* Перестановка (swap mutation) - случайно выбираются две аллели по которым происходит перестановка их генов. Задается параметром swap mutation.
* Вставка (insert mutation) – случайно выбираются два гена, затем второй помещается в позиции за первым геном. Задается параметром insert mutation.
* Перемешивание (scramble mutation) – случайно выбирается диапазон аллелей, в рамках которого все гены перемешиваются. Задается параметром  scramble mutation.
* Инверсия (inversion mutation) – случайно выбираются две аллели, между которыми все гены меняют свой порядок на противоположный. Задается параметром inversion mutation.

Параметры, которыми задаются все из этих мутаций - это количество раз, котоыре они применяется к случайной особи из популяции. 
![image](https://user-images.githubusercontent.com/91135334/224950933-4f2e8558-5d12-42a0-b186-3213955cafcb.png)

### def selectOne(population):

Это реализация Roulette-wheel selection, которая используется для выбора особей для вопсроизведения новых особей. В основе идеи метода лежит представление популяции в виде колеса рулетки, где для каждой особи имеется сектор, размер которого пропорционален значению её показателя приспособленности. Но так как мы стремимся к минимизации значений, поскольку они представляюи длину пути, а мы хотим получить самый короткий путь, то поделим 1 на все соотвеюущие значения для того, чтобы вы выбирали чаще те значения, которые меньше, а не больше. 

### Реализация

Далее в ячейки кода были собраны все ранее описанные функци для полноценной реализации генетического алгоритма. Рассмотрим более детально и построчно как ве работает.

В блоке ниже определяеются основные параметры.
```python3
GENERATIONS = 100000
POPULATIONS_SIZE = 500
COUNT_CITIES = 131
PRECENT_CROSSOVER = 0.9
best_ever = 10000000
elitism = 20 
```

В следующем локе кода мы начианем итерацию по поколениям GENERATIONS раз. Если это 1 поколение, то мы используем функцию  factory для создания 
```python3
population = []
for i in range(GENERATIONS):
  #factor
  if population == []:
    for j in range(POPULATIONS_SIZE):
      population += [factory(COUNT_CITIES)]
  # crossover
```


### Ответы на вопросы

1. Можно ли определить, что полученное решение является глобальным оптимумом?


2. Можно ли допускать невалидные решения (с повторением городов). Если да, то как обрабатывать такие решение и как это повлияет на производительность алгоритма?


3. Как изменится задача, если убрать условие необходимости возврата в исходную точку маршрута?






