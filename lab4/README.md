# Лабораторная работа №4 Генетический алгоритм для решения задачи коммивояжёра
## Цель работы
Целью данной работы является получение навыков разработки эволюционных алгоритмов для решения комбинаторных задач на примере задачи коммивояжера.
## Оборудование и программное обеспечение
Для выполнения лабораторной работы потребуется:
* браузер с доступом к сети Интернет
* Python > 3.9.16
## Ход работы
Задание данной лабораторной работы по согласованию с преподавателем было реализовано на языке Python. Для этого были реализованы следующие функции:

### def factory(count_cities)
Данная функция принимает на вход количество городов и на основе этого формирует первоначальные маршруты (нулевое поколение)

### def crossover(p1, p2)
Данная функция называется упорядоченным кроссовером и принимает на вход две особи -  родитель №1 и родитель №2. 
От родителя №1 ей достается отрезок генов от точки  a до точки b , а от родителя №2  все еще незадействованные гены, 
начиная от позиции b в порядке второго родителя. Подробный процесс представлен на рисунке ниже



![image](https://user-images.githubusercontent.com/91135334/224931099-6895d279-bfd1-4f62-9e30-5fd6aabc6694.png)

### def fintess_function(path, dict_cities)

Данная функция оценивает приспособленность особей популяции и выдает число, отражающее длину маршрута. Задача генетического алгоритма заключается в поиске особи с наименьшей оценкой, выданной фитнесс функцией.

### def selection(population, populations_size):
Данный оператор производит селекцию, это нужно для того чтобы размер популяции у нас оставался все время фиксированным.

### def mutation(individs)

Данная функция представляет собой оператор мутации, который вносит изменения в особи.

В работе реализовано 4 вида мутации: 

* Перестановка (swap mutation) - случайно выбираются две аллели по которым происходит перестановка их генов. Задается параметром swap mutation.
* Вставка (insert mutation) – случайно выбираются два гена, затем второй помещается в позиции за первым геном. Задается параметром insert mutation.
* Перемешивание (scramble mutation) – случайно выбирается диапазон аллелей, в рамках которого все гены перемешиваются. Задается параметром  scramble mutation.
* Инверсия (inversion mutation) – случайно выбираются две аллели, между которыми все гены меняют свой порядок на противоположный. Задается параметром inversion mutation.

Параметры, которыми задаются все из этих мутаций - это количество раз, которые они применяется к случайной особи из популяции. 
![image](https://user-images.githubusercontent.com/91135334/224950933-4f2e8558-5d12-42a0-b186-3213955cafcb.png)

### def selectOne(population):

Это реализация Roulette-wheel selection, которая используется для выбора особей для воспроизведения потомства. В основе идеи метода лежит представление популяции в виде колеса рулетки, где для каждой особи имеется сектор, размер которого пропорционален значению её показателя приспособленности. Но так как мы стремимся к минимизации значений, поскольку они представляют длину пути, и мы хотим получить самый короткий путь, то поделим 1 на все соответсвующие значения для того, чтобы выбирались чаще те значения, которые име.т меньшее значение оценки фитнесс-функции. 

### Реализация

Далее в ячейки кода были собраны все ранее описанные функции для полноценной реализации генетического алгоритма. Рассмотрим более детально и построчно как все работает.

В блоке ниже определяются основные параметры.

```python3
GENERATIONS = 100000
POPULATIONS_SIZE = 1500
COUNT_CITIES = 237
PRECENT_CROSSOVER = 0.9
best_ever = 10000000
ELETISM = 100
SWAP_MUTATION = 100
INSERT_MUTATION = 100
SCRAMBLE_MUTATION = 30
INVERSION_MUTATION = 30
```

В следующем блоке кода мы начинаем итерацию по поколениям GENERATIONS раз. Если это 1 поколение, то мы используем функцию  factory для создания нулевого поколения.
```python3
population = []
for i in range(GENERATIONS):
  #factor
  if population == []:
    for j in range(POPULATIONS_SIZE):
      population += [factory(COUNT_CITIES)]
```
Далее мы реализуем элитизм. Элитизм подразумевает, что одна или несколько особей текущего поколения переходят в следующее, не подвергаясь каким-либо изменениям, в отличие от всех остальных особей. Обычно в качестве элитной особи выбирается особь с наилучшим значением целевой функции, что и было реализовано.

```python3
# elitism
new_population = []
df = pd.DataFrame({"individ":population, "score": [fintess_function(i, dict_cities) for i in population]})
df = df.sort_values("score")
base = list(df["individ"][:ELETISM])
```
В следующем блоке создается новое количество особей, равное  PRECENT_CROSSOVER*(POPULATIONS_SIZE/2).
```python3
# crossover
for j in range(round(PRECENT_CROSSOVER*round(POPULATIONS_SIZE/2))):
  new_population += [crossover(selectOne(df),selectOne(df))]
population += new_population
```
Далее применяется мутация, задаваемая параметром SWAP_MUTATION, INSERT_MUTATION, SCRAMBLE_MUTATION, INVERSION_MUTATION.

```python3
#mutation
random.shuffle(population)
population = mutation(population, SWAP_MUTATION, INSERT_MUTATION, SCRAMBLE_MUTATION, INVERSION_MUTATION)
```
После этого проводится селекция, учитывающая тот факт, что был применен элитизм.
```python3
#selection
population, best_score = selection(population, POPULATIONS_SIZE- ELETISM)
population = base + population
```
В конце выводится номер поколения, лучшая особь в этом поколении, не считая элитарных, и лучшая особь существовавшая когда-либо. 
```python3
if best_score < best_ever:
  best_ever = best_score
print(f"Generation #{i}, best_score_ever = {best_ever}, best_current_score = {best_score}")
```


### Эксперимент
Для проведения экспериментальных исследований необходимо загрузить
с источника тестовых проблем несколько экземпляров задач с разной
размерностью (количеством городов). Для каждой задачи необходимо
настроить параметры алгоритма и провести минимум по 10 запусков. В
таблице ниже  представлены усредненные значения по результатам серий
запусков. Количество итераций до сходимости было вычислено вычислено путем
хранения лучшего решения в процессе эволюции и значения итерации, на
которой это решение было получено.

![image](https://user-images.githubusercontent.com/91135334/225070060-a50bfd1c-3121-4e5b-ba09-07d34c2e6a3f.png)


### Вывод

Таким образом, в данной лабораторной работы были реализованы операторы мутации, кроссовера и селекции, а также написан генетической алгоритм с полного нуля. Было замечено, что чем больше размер проблемы коммивояжера, тем больше итераций нужно до сходимости алгоритма, а также стоит выбирать более большой размер популяции и количества мутаций, чтобы получить приличный результат.  

## Ответы на вопросы

1. Можно ли определить, что полученное решение является глобальным оптимумом?

Нет, мы не можем быть уверены, что был найден глобальный оптимум, скорее всего был найден локальный оптимум наиболее похожий на глобальный.

2. Можно ли допускать невалидные решения (с повторением городов). Если да, то как обрабатывать такие решение и как это повлияет на производительность алгоритма?

Нет, поскольку невалидные решения будут провоцировать появления новых невалидных решений после мутации и кроссовера, их нужно будет контролировать и это сильно увеличит время работы и возможно получится ситуация, когда не выживет ни один валидный случай, то есть это негативно скажется на производительность алгоритма.


3. Как изменится задача, если убрать условие необходимости возврата в исходную точку маршрута?

Оптимальным маршрутом вероятно может быть совсем другой маршрут, с точки зрения кода изменится лишь несколько строк.
